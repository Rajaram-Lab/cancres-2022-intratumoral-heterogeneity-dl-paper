<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 7.1.1" />
    <title>tiler API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>



                    <h2>Contents</h2>
                    <ul>
  <li><a href="#features">Features</a></li>
  <li><a href="#quick-start">Quick start</a></li>
  <li><a href="#installation">Installation</a></li>
  <li><a href="#roadmap">Roadmap</a></li>
  <li><a href="#motivation-other-packages">Motivation &amp; other packages</a></li>
</ul>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#Tiler">Tiler</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Tiler.__init__">Tiler</a>
                        </li>
                        <li>
                                <a class="variable" href="#Tiler.TILING_MODES">TILING_MODES</a>
                        </li>
                        <li>
                                <a class="function" href="#Tiler.iterate">iterate</a>
                        </li>
                        <li>
                                <a class="function" href="#Tiler.get_tile">get_tile</a>
                        </li>
                        <li>
                                <a class="function" href="#Tiler.get_tile_bbox_position">get_tile_bbox_position</a>
                        </li>
                        <li>
                                <a class="function" href="#Tiler.get_tile_mosaic_position">get_tile_mosaic_position</a>
                        </li>
                        <li>
                                <a class="function" href="#Tiler.get_mosaic_shape">get_mosaic_shape</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Merger">Merger</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Merger.__init__">Merger</a>
                        </li>
                        <li>
                                <a class="variable" href="#Merger.SUPPORTED_WINDOWS">SUPPORTED_WINDOWS</a>
                        </li>
                        <li>
                                <a class="function" href="#Merger.set_window">set_window</a>
                        </li>
                        <li>
                                <a class="function" href="#Merger.reset">reset</a>
                        </li>
                        <li>
                                <a class="function" href="#Merger.add">add</a>
                        </li>
                        <li>
                                <a class="function" href="#Merger.add_batch">add_batch</a>
                        </li>
                        <li>
                                <a class="function" href="#Merger.merge">merge</a>
                        </li>
                </ul>

            </li>
    </ul>


                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
tiler    </h1>

                        <div class="docstring"><p><img src="tiler_teaser.png" alt="Tiler teaser image" /></p>

<p><a href="https://github.com/the-lay/tiler/actions/workflows/ci.yml"><img src="https://github.com/the-lay/tiler/workflows/CI/badge.svg" alt="CI" /></a>
<a href="https://coveralls.io/github/the-lay/tiler?branch=master"><img src="https://coveralls.io/repos/github/the-lay/tiler/badge.svg?branch=master" alt="Coverage status" /></a>
<a href="https://badge.fury.io/py/tiler"><img src="https://badge.fury.io/py/tiler.svg" alt="PyPI version" /></a>
<a href="https://pypistats.org/packages/tiler"><img src="https://img.shields.io/pypi/dm/tiler" alt="PyPI Downloads" /></a>
<a href="https://the-lay.github.io/tiler"><img src="https://img.shields.io/badge/documentation-✔-green.svg" alt="Documentation" /></a></p>

<p><a href="https://github.com/the-lay/tiler">Github repository</a> | 
<a href="https://github.com/the-lay/tiler/issues">Github issues</a> | 
<a href="https://the-lay.github.io/tiler">Documentation</a></p>

<hr />

<p>⚠️ <strong>Please note: work in progress, things will change and/or break!</strong> ⚠️</p>

<hr />

<p>This python package provides functions for tiling/patching and subsequent merging of NumPy arrays.</p>

<p>Such tiling is often required for various heavy image-processing tasks
such as semantic segmentation in deep learning, especially in domains where images do not fit into GPU memory
(e.g., hyperspectral satellite images, whole slide images, videos, tomography data).</p>

<h2 id="features">Features</h2>

<ul>
<li>N-dimensional <em>(note: currently tile shape must have the same number of dimensions as the array)</em></li>
<li>Optional in-place tiling</li>
<li>Optional channel dimension, dimension that is not tiled</li>
<li>Optional tile batching</li>
<li>Tile overlapping</li>
<li>Access individual tiles with iterator or a getter</li>
<li>Tile merging, with optional window functions/tapering</li>
</ul>

<h2 id="quick-start">Quick start</h2>

<p>This is an example of basic functionality. <br />
You can find more examples in <a href="https://github.com/the-lay/tiler/tree/master/examples">examples</a>. <br />
For more Tiler and Merger functionality, please check <a href="https://the-lay.github.io/tiler">documentation</a>.</p>

<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">tiler</span> <span class="kn">import</span> <span class="n">Tiler</span><span class="p">,</span> <span class="n">Merger</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">))</span>

<span class="c1"># Setup tiling parameters</span>
<span class="n">tiler</span> <span class="o">=</span> <span class="n">Tiler</span><span class="p">(</span><span class="n">data_shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
              <span class="n">tile_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">),</span>
              <span class="n">channel_dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">## Access tiles:</span>
<span class="c1"># 1. with an iterator</span>
<span class="k">for</span> <span class="n">tile_id</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tiler</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
   <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tiler</span><span class="p">)</span><span class="si">}</span><span class="s1"> tiles.&#39;</span><span class="p">)</span>
<span class="c1"># 1b. the iterator can also be accessed through __call__</span>
<span class="k">for</span> <span class="n">tile_id</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tiler</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
   <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tiler</span><span class="p">)</span><span class="si">}</span><span class="s1"> tiles.&#39;</span><span class="p">)</span>
<span class="c1"># 2. individually</span>
<span class="n">tile_3</span> <span class="o">=</span> <span class="n">tiler</span><span class="o">.</span><span class="n">get_tile</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># 3. in batches</span>
<span class="n">tiles_in_batches</span> <span class="o">=</span> <span class="p">[</span><span class="n">batch</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tiler</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)]</span>

<span class="c1"># Setup merging parameters</span>
<span class="n">merger</span> <span class="o">=</span> <span class="n">Merger</span><span class="p">(</span><span class="n">tiler</span><span class="p">)</span>

<span class="c1">## Merge tiles:</span>
<span class="c1"># 1. one by one</span>
<span class="k">for</span> <span class="n">tile_id</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tiler</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
   <span class="n">merger</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tile_id</span><span class="p">,</span> <span class="n">some_processing_fn</span><span class="p">(</span><span class="n">tile</span><span class="p">))</span>
<span class="c1"># 2. in batches</span>
<span class="n">merger</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="k">for</span> <span class="n">batch_id</span><span class="p">,</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tiler</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
   <span class="n">merger</span><span class="o">.</span><span class="n">add_batch</span><span class="p">(</span><span class="n">batch_id</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">batch</span><span class="p">)</span>

<span class="c1"># Final merging: applies tapering and optional unpadding</span>
<span class="n">final_image</span> <span class="o">=</span> <span class="n">merger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">unpad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># (3, 1920, 1080)</span>
</code></pre></div>

<h2 id="installation">Installation</h2>

<p>The latest release is available through pip:</p>

<div class="codehilite"><pre><span></span><code>pip install tiler
</code></pre></div>

<p>Alternatively, you can clone the repository and install it manually:</p>

<div class="codehilite"><pre><span></span><code>git clone git@github.com:the-lay/tiler.git
<span class="nb">cd</span> tiler
pip install
</code></pre></div>

<h2 id="roadmap">Roadmap</h2>

<ul>
<li>Easy generation of tiling for a specific window in mind
(i.e. so that every element has the window weight sum of 1.0)</li>
<li>Add border windows generation (like in Pielawski et. al - see references))</li>
<li>PyTorch Tensors support
<ul>
<li>merging on GPU like in pytorch-toolbelt?</li>
</ul></li>
<li>More examples</li>
<li>PyTorch Dataset class convenience wrapper?</li>
<li>Arbitrary sized tiles (m-dim window over n-dim array, m &lt;= n)?
<ul>
<li><a href="https://stackoverflow.com/questions/45960192/using-numpy-as-strided-function-to-create-patches-tiles-rolling-or-sliding-w">Some leads here</a></li>
</ul></li>
<li>Optional augmentation modes for smoother segmentations?
<ul>
<li>D4 rotation group</li>
<li>Mirroring</li>
</ul></li>
<li>Benchmark with plain for loops, determine overhead</li>
</ul>

<h2 id="motivation-other-packages">Motivation &amp; other packages</h2>

<p>I work on semantic segmentation of patched 3D data and
I often found myself reusing tiling functions that I wrote for the previous projects.
No existing libraries listed below fit my use case, so that's why I wrote this library.</p>

<p>However, other libraries might fit you better:</p>

<ul>
<li><a href="https://github.com/vfdev-5/ImageTilingUtils">vfdev-5/ImageTilingUtils</a>
<ul>
<li>Minimalistic image reader agnostic 2D tiling tools</li>
</ul></li>
</ul>

<ul>
<li><p><a href="https://github.com/BloodAxe/pytorch-toolbelt#inference-on-huge-images">BloodAxe/pytorch-toolbelt</a></p>

<ul>
<li>Powerful PyTorch toolset that has 2D image tiling and on-GPU merger</li>
</ul></li>
<li><p><a href="https://github.com/Vooban/Smoothly-Blend-Image-Patches">Vooban/Smoothly-Blend-Image-Patches</a></p>

<ul>
<li>Mirroring and D4 rotations data (8-fold) augmentation with squared spline window function for 2D images</li>
</ul></li>
<li><p><a href="https://github.com/samdobson/image_slicer">samdobson/image_slicer</a></p>

<ul>
<li>Slicing and merging 2D image into N equally sized tiles</li>
</ul></li>
<li><p><a href="https://github.com/dovahcrow/patchify.py">dovahcrow/patchify.py</a></p>

<ul>
<li>Tile and merge 2D, 3D images defined by tile shapes and step between tiles</li>
</ul></li>
<li><p>Do you know any other similar packages?</p>

<ul>
<li><a href="https://github.com/the-lay/tiler/pulls">Please make a PR</a> or <a href="https://github.com/the-lay/tiler/issues">open a new issue</a>.</li>
</ul></li>
</ul>

<p>Moreover, some related approaches have been described in the literature:</p>

<ul>
<li><a href="https://doi.org/10.1371/journal.pone.0229839
">Introducing Hann windows for reducing edge-effects in patch-based image segmentation</a>, Pielawski and Wählby, March 2020</li>
</ul>

<!-- for later
For more examples, please see examples/ folder
```python

 ```

Benchmarks
-------------
 Benchmarks?


Examples
-------------
https://github.com/BloodAxe/pytorch-toolbelt#inference-on-huge-images
https://github.com/BloodAxe/pytorch-toolbelt/blob/master/pytorch_toolbelt/inference/tiles.py

https://github.com/vfdev-5/ImageTilingUtils

https://github.com/Vooban/Smoothly-Blend-Image-Patches/blob/master/smooth_tiled_predictions.py

for windows:
https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python

https://en.wikipedia.org/wiki/Window_function#A_list_of_window_functions
https://github.com/scipy/scipy/blob/v1.4.1/scipy/signal/windows/windows.py
https://gist.github.com/npielawski/7e77d23209a5c415f55b95d4aba914f6

https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0229839#pone.0229839.ref005
https://arxiv.org/pdf/1803.02786.pdf
-->
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">tiler.tiler</span> <span class="kn">import</span> <span class="n">Tiler</span>
<span class="kn">from</span> <span class="nn">tiler.merger</span> <span class="kn">import</span> <span class="n">Merger</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;0.3.0&#39;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Tiler&#39;</span><span class="p">,</span> <span class="s1">&#39;Merger&#39;</span><span class="p">]</span>

<span class="c1"># Import README file as a module general docstring, only when generating documentation</span>
<span class="c1"># We also modify it to make it prettier</span>
<span class="k">if</span> <span class="s2">&quot;pdoc&quot;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;README.md&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">_readme</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">_readme</span> <span class="o">=</span> <span class="n">_readme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;# tiler&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove header</span>
        <span class="n">_readme</span> <span class="o">=</span> <span class="n">_readme</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;misc/teaser/tiler_teaser.png&#39;</span><span class="p">,</span> <span class="s1">&#39;tiler_teaser.png&#39;</span><span class="p">)</span>  <span class="c1"># replace image path</span>
        <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_readme</span>
</pre></div>

        </details>

            </section>
                <section id="Tiler">
                                <div class="attr class">
        <a class="headerlink" href="#Tiler">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Tiler</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Tiler</span><span class="p">:</span>
    <span class="n">TILING_MODES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;drop&#39;</span><span class="p">,</span> <span class="s1">&#39;irregular&#39;</span><span class="p">,</span> <span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">]</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Supported tiling modes:</span>
<span class="sd">    - `constant` (default)  </span>
<span class="sd">        If a tile is smaller than `tile_shape`, pad it with the constant value along each axis to match `tile_shape`.</span>
<span class="sd">        Set the value with the keyword `constant_value`.  </span>
<span class="sd">    - `drop`  </span>
<span class="sd">        If a tile is smaller than `tile_shape` in any of the dimensions, ignore it. Can result in zero tiles.</span>
<span class="sd">    - `irregular`  </span>
<span class="sd">        Allow tiles to be smaller than `tile_shape`.</span>
<span class="sd">    - `reflect`  </span>
<span class="sd">        If a tile is smaller than `tile_shape`,</span>
<span class="sd">        pad it with the reflection of values along each axis to match `tile_shape`.</span>
<span class="sd">    - `edge`  </span>
<span class="sd">        If a tile is smaller than `tile_shape`,</span>
<span class="sd">        pad it with the edge values of data along each axis to match `tile_shape`.</span>
<span class="sd">    - `wrap`  </span>
<span class="sd">        If a tile is smaller than `tile_shape`,</span>
<span class="sd">        pad it with the wrap of the vector along each axis to match `tile_shape`.</span>
<span class="sd">        The first values are used to pad the end and the end values are used to pad the beginning.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">],</span>
                 <span class="n">tile_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">],</span>
                 <span class="n">overlap</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">channel_dimension</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                 <span class="n">constant_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tiler class precomputes everything for tiling with specified parameters, without actually slicing data.</span>
<span class="sd">        You can access tiles individually with `Tiler.get_tile()` or with an iterator, both individually and in batches,</span>
<span class="sd">        with `Tiler.iterate()` (or the alias `Tiler.__call__()`).</span>

<span class="sd">        TODO:</span>
<span class="sd">            - it should be possible to create tiles with fewer dimensions then data (len(tile_shape) &lt; len(data_shape)</span>
<span class="sd">            - allow a user supplied padding function, Callable (input: tile, tile_shape; output: padded_tile)</span>
<span class="sd">            - allow other numpy padding modes (maximum, minimum, mean, median)</span>

<span class="sd">        Args:</span>
<span class="sd">            data_shape (tuple or list): Input data shape, e.g. (1920, 1080, 3) or [512, 512, 512].</span>
<span class="sd">                If there is a channel dimension, it should be included in the shape.</span>

<span class="sd">            tile_shape (tuple or list): Shape of a tile, e.g. (256, 256, 3) or [64, 64, 64].</span>
<span class="sd">                Tile must have the same number of dimensions as data.</span>

<span class="sd">            overlap (int, float, tuple or list): Specifies overlap between tiles.</span>
<span class="sd">                If integer, the same overlap of overlap pixels applied in each dimension, except channel_dimension.</span>
<span class="sd">                If float, percentage of a tile_shape to overlap (from 0.0 to 1.0), except channel_dimension.</span>
<span class="sd">                If tuple or list, explicit size of the overlap (must be smaller than tile_shape).</span>
<span class="sd">                Default is `0`.</span>

<span class="sd">            channel_dimension (int, optional): Specifies which axis is the channel dimension that will not be tiled.</span>
<span class="sd">                Usually it is the last or the first dimension of the array.</span>
<span class="sd">                Negative indexing (`-len(data_shape)` to `-1` inclusive) is translated into corresponding indices.</span>
<span class="sd">                Default is `None`, no channel dimension in the data.</span>

<span class="sd">            mode (str): Defines how the data will be tiled.</span>
<span class="sd">                Must be one of the supported `Tiler.TILING_MODES`.</span>

<span class="sd">            constant_value (float): Specifies the value of padding when `mode=&#39;constant&#39;`.</span>
<span class="sd">                Default is `0.0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Data and tile shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Tile and data shapes must be tuple or lists of positive numbers.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Tile and data shapes must have the same length.&#39;</span><span class="p">)</span>

        <span class="c1"># Tiling mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TILING_MODES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="si">}</span><span class="s1"> is an unsupported tiling mode, please check the documentation.&#39;</span><span class="p">)</span>

        <span class="c1"># Constant value used for constant tiling mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_value</span> <span class="o">=</span> <span class="n">constant_value</span>

        <span class="c1"># Channel dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">=</span> <span class="n">channel_dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Specified channel dimension is out of bounds &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;(should be None or an integer from </span><span class="si">{</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># negative indexing</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span>

        <span class="c1"># Overlap and step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Float overlap must be in range of 0.0 (0%) to 1.0 (100%).&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">tile_shape_without_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&gt;=</span> <span class="n">tile_shape_without_channel</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Integer overlap must be in range of 0 to </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tile_shape_without_channel</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Overlap size much be smaller than tile_shape.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unsupported overlap mode (not float, int, list or tuple).&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># tile step</span>

        <span class="c1"># Calculate mosaic (collection of tiles) shape</span>
        <span class="n">div</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;drop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span> <span class="o">=</span> <span class="n">div</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span> <span class="o">=</span> <span class="n">div</span> <span class="o">+</span> <span class="p">(</span><span class="n">mod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Calculate new shape assuming tiles are padded</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;irregular&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_shape</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape_diff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># If channel dimension is given, set tile_step of that dimension to 0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Tile indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Tiler (mode=</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">, overlap=</span><span class="si">{</span><span class="n">overlap</span><span class="si">}</span><span class="s1">) will split data_shape </span><span class="si">{</span><span class="n">data_shape</span><span class="si">}</span><span class="s1"> &#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;into zero tiles (tile_shape=</span><span class="si">{</span><span class="n">tile_shape</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">             int: Number of tiles in the mosaic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            str: String representation of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Tiler split </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">)</span><span class="si">}</span><span class="s1"> data into </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1"> tiles of </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span> \
               <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">Mosaic shape: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> \
               <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">Padded shape: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_shape</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> \
               <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">Tile overlap: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="si">}</span><span class="s1">&#39;</span> \
               <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">Element step: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> \
               <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">Mode: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="si">}</span><span class="s1">&#39;</span> \
               <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">Channel dimension: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                <span class="n">progress_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">drop_last</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">copy_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Iterates through tiles of the given data array. This method can also be accessed by `Tiler.__call__()`.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray or callable): The data array on which the tiling will be performed. A callable can be</span>
<span class="sd">                supplied to load data into memory instead of slicing from an array. The callable should take integers</span>
<span class="sd">                as input, the smallest tile corner coordinates and tile size in each dimension, and output numpy array.</span>

<span class="sd">                e.g.</span>
<span class="sd">                *python-bioformats*</span>
<span class="sd">                ```python</span>
<span class="sd">                &gt;&gt;&gt; tileSize = 2000</span>
<span class="sd">                &gt;&gt;&gt; tiler = Tiler((sizeX, sizeY, sizeC), (tileSize, tileSize, sizeC))</span>
<span class="sd">                &gt;&gt;&gt; def reader_func(*args):</span>
<span class="sd">                &gt;&gt;&gt;     X, Y, W, H = args[0], args[1], args[3], args[4]</span>
<span class="sd">                &gt;&gt;&gt;     return reader.read(XYWH=[X, Y, W, H])</span>
<span class="sd">                &gt;&gt;&gt; for t_id, tile in tiler.iterate(reader_func):</span>
<span class="sd">                &gt;&gt;&gt;     pass</span>
<span class="sd">                ```</span>
<span class="sd">                *open-slide*</span>
<span class="sd">                ```python</span>
<span class="sd">                &gt;&gt;&gt; reader_func = lambda *args: wsi.read_region([args[0], args[1]], 0, [args[3], args[4]])</span>
<span class="sd">                &gt;&gt;&gt; for t_id, tile in tiler.iterate(reader_func):</span>
<span class="sd">                &gt;&gt;&gt;     pass</span>
<span class="sd">                ```</span>

<span class="sd">            progress_bar (bool): Specifies whether to show the progress bar or not.</span>
<span class="sd">                Uses `tqdm` package.</span>
<span class="sd">                Default is `False`.</span>

<span class="sd">            batch_size (int): Specifies returned batch size.</span>
<span class="sd">                If `batch_size == 0`, return one tile at a time.</span>
<span class="sd">                If `batch_size &gt;= 1`, return in batches (returned shape: `[batch_size, *tile_shape]`).</span>
<span class="sd">                Default is 0.</span>

<span class="sd">            drop_last (bool): Specifies whether to drop last non-full batch.</span>
<span class="sd">                Used only when batch_size &gt; 0.</span>
<span class="sd">                Default is False.</span>

<span class="sd">            copy_data (bool): Specifies whether to copy the tile before returning it.</span>
<span class="sd">                If `copy_data == False`, returns a view.</span>
<span class="sd">                Default is True.</span>

<span class="sd">        Yields:</span>
<span class="sd">            (int, np.ndarray): Tuple with integer tile number and array tile data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Batch size must &gt;= 0, not </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># return a tile at a time</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tile_i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; tiles&#39;</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">tile_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tile_i</span><span class="p">,</span> <span class="n">copy_data</span><span class="o">=</span><span class="n">copy_data</span><span class="p">)</span>

        <span class="c1"># return in batches</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># check for drop_last</span>
            <span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">%</span> <span class="n">batch_size</span><span class="p">))</span> <span class="k">if</span> <span class="n">drop_last</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span>

            <span class="k">for</span> <span class="n">tile_i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; batches&#39;</span><span class="p">):</span>
                <span class="n">tiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy_data</span><span class="o">=</span><span class="n">copy_data</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span>
                                  <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_i</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tile_i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">length</span><span class="p">))])</span>
                <span class="k">yield</span> <span class="n">tile_i</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">tiles</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                 <span class="n">progress_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">drop_last</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">copy_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; Alias for `Tiler.iterate()` &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_last</span><span class="p">,</span> <span class="n">copy_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                 <span class="n">tile_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">copy_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns an individual tile.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray or callable): Data from which `tile_id`-th tile will be taken. A callable can be</span>
<span class="sd">                supplied to load data into memory instead of slicing from an array. The callable should take integers</span>
<span class="sd">                as input, the smallest tile corner coordinates and tile size in each dimension, and output numpy array.</span>

<span class="sd">                e.g.</span>
<span class="sd">                *python-bioformats*</span>
<span class="sd">                ```python</span>
<span class="sd">                &gt;&gt;&gt; tileSize = 2000</span>
<span class="sd">                &gt;&gt;&gt; tiler = Tiler((sizeX, sizeY, sizeC), (tileSize, tileSize, sizeC))</span>
<span class="sd">                &gt;&gt;&gt; def reader_func(*args):</span>
<span class="sd">                &gt;&gt;&gt;     X, Y, W, H = args[0], args[1], args[3], args[4]</span>
<span class="sd">                &gt;&gt;&gt;     return reader.read(XYWH=[X, Y, W, H])</span>
<span class="sd">                &gt;&gt;&gt; tiler.get_tile(reader_func, 0)</span>
<span class="sd">                ```</span>
<span class="sd">                *open-slide*</span>
<span class="sd">                ```python</span>
<span class="sd">                &gt;&gt;&gt; reader_func = lambda *args: wsi.read_region([args[0], args[1]], 0, [args[3], args[4]])</span>
<span class="sd">                &gt;&gt;&gt; tiler.get_tile(reader_func, 0)</span>
<span class="sd">                ```</span>

<span class="sd">            tile_id (int): Specifies which tile to return. Must be smaller than the total number of tiles.</span>

<span class="sd">            copy_data (bool): Specifies whether returned tile is a copy.</span>
<span class="sd">                If `copy_data == False` returns a view.</span>
<span class="sd">                Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Content of tile number `tile_id`, padded if necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds, there is no tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1">.&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> tiles, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="c1"># get tile data</span>
        <span class="n">tile_corner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="p">[</span><span class="n">tile_id</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span>
        <span class="c1"># take the lesser of the tile shape and the distance to the edge</span>
        <span class="n">sampling</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">tile_corner</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">tile_corner</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">[</span><span class="n">d</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">sampling</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sampling</span><span class="p">]</span>
            <span class="n">tile_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">(</span><span class="o">*</span><span class="n">tile_corner</span><span class="p">,</span> <span class="o">*</span><span class="n">sampling</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tile_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sampling</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">copy_data</span><span class="p">:</span>
            <span class="n">tile_data</span> <span class="o">=</span> <span class="n">tile_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">shape_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">-</span> <span class="n">tile_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;irregular&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">shape_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
                <span class="n">tile_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">tile_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">shape_diff</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
                                   <span class="n">constant_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constant_value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;reflect&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
                <span class="n">tile_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">tile_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">shape_diff</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tile_data</span>

    <span class="k">def</span> <span class="nf">get_tile_bbox_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">with_channel_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns opposite corners coordinates of bounding hyperrectangle of the tile on padded data.</span>

<span class="sd">        Args:</span>
<span class="sd">            tile_id (int): Specifies which tile&#39;s bounding coordinates will be returned.</span>
<span class="sd">                Must be smaller than the total number of tiles.</span>

<span class="sd">            with_channel_dim (bool): Specifies whether to return shape with channel dimension or without.</span>
<span class="sd">                Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.ndarray): Smallest and largest corners of the bounding box.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds, there is no tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1">. &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> tiles, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="n">starting_corner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tile_mosaic_position</span><span class="p">(</span><span class="n">tile_id</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">finish_corner</span> <span class="o">=</span> <span class="n">starting_corner</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">with_channel_dim</span><span class="p">:</span>
            <span class="n">dim_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">))</span> <span class="o">+</span> \
                          <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">)))</span>
            <span class="n">starting_corner</span> <span class="o">=</span> <span class="n">starting_corner</span><span class="p">[</span><span class="n">dim_indices</span><span class="p">]</span>
            <span class="n">finish_corner</span> <span class="o">=</span> <span class="n">finish_corner</span><span class="p">[</span><span class="n">dim_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">starting_corner</span><span class="p">,</span> <span class="n">finish_corner</span>

    <span class="k">def</span> <span class="nf">get_tile_mosaic_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">with_channel_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns tile position in the mosaic.</span>

<span class="sd">        Args:</span>
<span class="sd">          tile_id (int): Specifies which tile&#39;s mosaic position will be returned. \</span>
<span class="sd">            Must be smaller than the total number of tiles.</span>
<span class="sd">          with_channel_dim (bool): Specifies whether to return position with channel dimension or without.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Tile mosaic position (tile position relative to other tiles).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds, there is no tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1">. &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> tiles, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">with_channel_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="p">[</span><span class="n">tile_id</span><span class="p">][</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="p">[</span><span class="n">tile_id</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_mosaic_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_channel_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns mosaic shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            with_channel_dim (bool):</span>
<span class="sd">                Specifies whether to return shape with channel dimension or without. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Shape of tiles mosaic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">with_channel_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span>
</pre></div>

        </details>

    

                            <div id="Tiler.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Tiler.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Tiler</span><span class="signature">(
    data_shape: Union[Tuple, List],
    tile_shape: Union[Tuple, List],
    overlap: Union[int, float, Tuple, List] = 0,
    channel_dimension: Union[int, NoneType] = None,
    mode: str = &#39;constant&#39;,
    constant_value: float = 0.0
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">],</span>
                 <span class="n">tile_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">],</span>
                 <span class="n">overlap</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">channel_dimension</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                 <span class="n">constant_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tiler class precomputes everything for tiling with specified parameters, without actually slicing data.</span>
<span class="sd">        You can access tiles individually with `Tiler.get_tile()` or with an iterator, both individually and in batches,</span>
<span class="sd">        with `Tiler.iterate()` (or the alias `Tiler.__call__()`).</span>

<span class="sd">        TODO:</span>
<span class="sd">            - it should be possible to create tiles with fewer dimensions then data (len(tile_shape) &lt; len(data_shape)</span>
<span class="sd">            - allow a user supplied padding function, Callable (input: tile, tile_shape; output: padded_tile)</span>
<span class="sd">            - allow other numpy padding modes (maximum, minimum, mean, median)</span>

<span class="sd">        Args:</span>
<span class="sd">            data_shape (tuple or list): Input data shape, e.g. (1920, 1080, 3) or [512, 512, 512].</span>
<span class="sd">                If there is a channel dimension, it should be included in the shape.</span>

<span class="sd">            tile_shape (tuple or list): Shape of a tile, e.g. (256, 256, 3) or [64, 64, 64].</span>
<span class="sd">                Tile must have the same number of dimensions as data.</span>

<span class="sd">            overlap (int, float, tuple or list): Specifies overlap between tiles.</span>
<span class="sd">                If integer, the same overlap of overlap pixels applied in each dimension, except channel_dimension.</span>
<span class="sd">                If float, percentage of a tile_shape to overlap (from 0.0 to 1.0), except channel_dimension.</span>
<span class="sd">                If tuple or list, explicit size of the overlap (must be smaller than tile_shape).</span>
<span class="sd">                Default is `0`.</span>

<span class="sd">            channel_dimension (int, optional): Specifies which axis is the channel dimension that will not be tiled.</span>
<span class="sd">                Usually it is the last or the first dimension of the array.</span>
<span class="sd">                Negative indexing (`-len(data_shape)` to `-1` inclusive) is translated into corresponding indices.</span>
<span class="sd">                Default is `None`, no channel dimension in the data.</span>

<span class="sd">            mode (str): Defines how the data will be tiled.</span>
<span class="sd">                Must be one of the supported `Tiler.TILING_MODES`.</span>

<span class="sd">            constant_value (float): Specifies the value of padding when `mode=&#39;constant&#39;`.</span>
<span class="sd">                Default is `0.0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Data and tile shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Tile and data shapes must be tuple or lists of positive numbers.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Tile and data shapes must have the same length.&#39;</span><span class="p">)</span>

        <span class="c1"># Tiling mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TILING_MODES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="si">}</span><span class="s1"> is an unsupported tiling mode, please check the documentation.&#39;</span><span class="p">)</span>

        <span class="c1"># Constant value used for constant tiling mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_value</span> <span class="o">=</span> <span class="n">constant_value</span>

        <span class="c1"># Channel dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">=</span> <span class="n">channel_dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Specified channel dimension is out of bounds &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;(should be None or an integer from </span><span class="si">{</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># negative indexing</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span>

        <span class="c1"># Overlap and step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Float overlap must be in range of 0.0 (0%) to 1.0 (100%).&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">tile_shape_without_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&gt;=</span> <span class="n">tile_shape_without_channel</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Integer overlap must be in range of 0 to </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tile_shape_without_channel</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Overlap size much be smaller than tile_shape.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unsupported overlap mode (not float, int, list or tuple).&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># tile step</span>

        <span class="c1"># Calculate mosaic (collection of tiles) shape</span>
        <span class="n">div</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;drop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span> <span class="o">=</span> <span class="n">div</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span> <span class="o">=</span> <span class="n">div</span> <span class="o">+</span> <span class="p">(</span><span class="n">mod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Calculate new shape assuming tiles are padded</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;irregular&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_shape</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape_diff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># If channel dimension is given, set tile_step of that dimension to 0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Tile indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Tiler (mode=</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">, overlap=</span><span class="si">{</span><span class="n">overlap</span><span class="si">}</span><span class="s1">) will split data_shape </span><span class="si">{</span><span class="n">data_shape</span><span class="si">}</span><span class="s1"> &#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;into zero tiles (tile_shape=</span><span class="si">{</span><span class="n">tile_shape</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Tiler class precomputes everything for tiling with specified parameters, without actually slicing data.
You can access tiles individually with <code><a href="#Tiler.get_tile">Tiler.get_tile()</a></code> or with an iterator, both individually and in batches,
with <code><a href="#Tiler.iterate">Tiler.iterate()</a></code> (or the alias <code>Tiler.__call__()</code>).</p>

<h6 id="todo">TODO</h6>

<blockquote>
  <ul>
  <li>it should be possible to create tiles with fewer dimensions then data (len(tile_shape) &lt; len(data_shape)</li>
  <li>allow a user supplied padding function, Callable (input: tile, tile_shape; output: padded_tile)</li>
  <li>allow other numpy padding modes (maximum, minimum, mean, median)</li>
  </ul>
</blockquote>

<h6 id="args">Args</h6>

<ul>
<li><strong>data_shape (tuple or list):</strong>  Input data shape, e.g. (1920, 1080, 3) or [512, 512, 512].
If there is a channel dimension, it should be included in the shape.</li>
<li><strong>tile_shape (tuple or list):</strong>  Shape of a tile, e.g. (256, 256, 3) or [64, 64, 64].
Tile must have the same number of dimensions as data.</li>
<li><strong>overlap (int, float, tuple or list):</strong>  Specifies overlap between tiles.
If integer, the same overlap of overlap pixels applied in each dimension, except channel_dimension.
If float, percentage of a tile_shape to overlap (from 0.0 to 1.0), except channel_dimension.
If tuple or list, explicit size of the overlap (must be smaller than tile_shape).
Default is <code>0</code>.</li>
<li><strong>channel_dimension (int, optional):</strong>  Specifies which axis is the channel dimension that will not be tiled.
Usually it is the last or the first dimension of the array.
Negative indexing (<code>-len(data_shape)</code> to <code>-1</code> inclusive) is translated into corresponding indices.
Default is <code>None</code>, no channel dimension in the data.</li>
<li><strong>mode (str):</strong>  Defines how the data will be tiled.
Must be one of the supported <code><a href="#Tiler.TILING_MODES">Tiler.TILING_MODES</a></code>.</li>
<li><strong>constant_value (float):</strong>  Specifies the value of padding when <code>mode='constant'</code>.
Default is <code>0.0</code>.</li>
</ul>
</div>


                            </div>
                            <div id="Tiler.TILING_MODES" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Tiler.TILING_MODES">#&nbsp;&nbsp</a>

        <span class="name">TILING_MODES</span><span class="default_value"> = [&#39;constant&#39;, &#39;drop&#39;, &#39;irregular&#39;, &#39;reflect&#39;, &#39;edge&#39;, &#39;wrap&#39;]</span>
    </div>

            <div class="docstring"><p>Supported tiling modes:</p>

<ul>
<li><code>constant</code> (default) <br />
If a tile is smaller than <code>tile_shape</code>, pad it with the constant value along each axis to match <code>tile_shape</code>.
Set the value with the keyword <code>constant_value</code>.  </li>
<li><code>drop</code> <br />
If a tile is smaller than <code>tile_shape</code> in any of the dimensions, ignore it. Can result in zero tiles.</li>
<li><code>irregular</code> <br />
Allow tiles to be smaller than <code>tile_shape</code>.</li>
<li><code>reflect</code> <br />
If a tile is smaller than <code>tile_shape</code>,
pad it with the reflection of values along each axis to match <code>tile_shape</code>.</li>
<li><code>edge</code> <br />
If a tile is smaller than <code>tile_shape</code>,
pad it with the edge values of data along each axis to match <code>tile_shape</code>.</li>
<li><code>wrap</code> <br />
If a tile is smaller than <code>tile_shape</code>,
pad it with the wrap of the vector along each axis to match <code>tile_shape</code>.
The first values are used to pad the end and the end values are used to pad the beginning.</li>
</ul>
</div>


                            </div>
                            <div id="Tiler.iterate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Tiler.iterate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">iterate</span><span class="signature">(
    self,
    data: Union[numpy.ndarray, Callable[..., numpy.ndarray]],
    progress_bar: bool = False,
    batch_size: int = 0,
    drop_last: bool = False,
    copy_data: bool = True
) -&gt; Generator[Tuple[int, numpy.ndarray], NoneType, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                <span class="n">progress_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">drop_last</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">copy_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Iterates through tiles of the given data array. This method can also be accessed by `Tiler.__call__()`.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray or callable): The data array on which the tiling will be performed. A callable can be</span>
<span class="sd">                supplied to load data into memory instead of slicing from an array. The callable should take integers</span>
<span class="sd">                as input, the smallest tile corner coordinates and tile size in each dimension, and output numpy array.</span>

<span class="sd">                e.g.</span>
<span class="sd">                *python-bioformats*</span>
<span class="sd">                ```python</span>
<span class="sd">                &gt;&gt;&gt; tileSize = 2000</span>
<span class="sd">                &gt;&gt;&gt; tiler = Tiler((sizeX, sizeY, sizeC), (tileSize, tileSize, sizeC))</span>
<span class="sd">                &gt;&gt;&gt; def reader_func(*args):</span>
<span class="sd">                &gt;&gt;&gt;     X, Y, W, H = args[0], args[1], args[3], args[4]</span>
<span class="sd">                &gt;&gt;&gt;     return reader.read(XYWH=[X, Y, W, H])</span>
<span class="sd">                &gt;&gt;&gt; for t_id, tile in tiler.iterate(reader_func):</span>
<span class="sd">                &gt;&gt;&gt;     pass</span>
<span class="sd">                ```</span>
<span class="sd">                *open-slide*</span>
<span class="sd">                ```python</span>
<span class="sd">                &gt;&gt;&gt; reader_func = lambda *args: wsi.read_region([args[0], args[1]], 0, [args[3], args[4]])</span>
<span class="sd">                &gt;&gt;&gt; for t_id, tile in tiler.iterate(reader_func):</span>
<span class="sd">                &gt;&gt;&gt;     pass</span>
<span class="sd">                ```</span>

<span class="sd">            progress_bar (bool): Specifies whether to show the progress bar or not.</span>
<span class="sd">                Uses `tqdm` package.</span>
<span class="sd">                Default is `False`.</span>

<span class="sd">            batch_size (int): Specifies returned batch size.</span>
<span class="sd">                If `batch_size == 0`, return one tile at a time.</span>
<span class="sd">                If `batch_size &gt;= 1`, return in batches (returned shape: `[batch_size, *tile_shape]`).</span>
<span class="sd">                Default is 0.</span>

<span class="sd">            drop_last (bool): Specifies whether to drop last non-full batch.</span>
<span class="sd">                Used only when batch_size &gt; 0.</span>
<span class="sd">                Default is False.</span>

<span class="sd">            copy_data (bool): Specifies whether to copy the tile before returning it.</span>
<span class="sd">                If `copy_data == False`, returns a view.</span>
<span class="sd">                Default is True.</span>

<span class="sd">        Yields:</span>
<span class="sd">            (int, np.ndarray): Tuple with integer tile number and array tile data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Batch size must &gt;= 0, not </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># return a tile at a time</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tile_i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; tiles&#39;</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">tile_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tile_i</span><span class="p">,</span> <span class="n">copy_data</span><span class="o">=</span><span class="n">copy_data</span><span class="p">)</span>

        <span class="c1"># return in batches</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># check for drop_last</span>
            <span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">%</span> <span class="n">batch_size</span><span class="p">))</span> <span class="k">if</span> <span class="n">drop_last</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span>

            <span class="k">for</span> <span class="n">tile_i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; batches&#39;</span><span class="p">):</span>
                <span class="n">tiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy_data</span><span class="o">=</span><span class="n">copy_data</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span>
                                  <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_i</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tile_i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">length</span><span class="p">))])</span>
                <span class="k">yield</span> <span class="n">tile_i</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">tiles</span>
</pre></div>

        </details>

            <div class="docstring"><p>Iterates through tiles of the given data array. This method can also be accessed by <code>Tiler.__call__()</code>.</p>

<h6 id="args">Args</h6>

<ul>
<li><p><strong>data (np.ndarray or callable):</strong>  The data array on which the tiling will be performed. A callable can be
supplied to load data into memory instead of slicing from an array. The callable should take integers
as input, the smallest tile corner coordinates and tile size in each dimension, and output numpy array.</p>

<p>e.g.
<em>python-bioformats</em></p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">tileSize</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tiler</span> <span class="o">=</span> <span class="n">Tiler</span><span class="p">((</span><span class="n">sizeX</span><span class="p">,</span> <span class="n">sizeY</span><span class="p">,</span> <span class="n">sizeC</span><span class="p">),</span> <span class="p">(</span><span class="n">tileSize</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">,</span> <span class="n">sizeC</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">reader_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">return</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">XYWH</span><span class="o">=</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">t_id</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tiler</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">reader_func</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">pass</span>
</code></pre></div>

<p><em>open-slide</em></p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">reader_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">wsi</span><span class="o">.</span><span class="n">read_region</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">t_id</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tiler</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">reader_func</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">pass</span>
</code></pre></div></li>
<li><strong>progress_bar (bool):</strong>  Specifies whether to show the progress bar or not.
Uses <code>tqdm</code> package.
Default is <code>False</code>.</li>
<li><strong>batch_size (int):</strong>  Specifies returned batch size.
If <code>batch_size == 0</code>, return one tile at a time.
If <code>batch_size &gt;= 1</code>, return in batches (returned shape: <code>[batch_size, *tile_shape]</code>).
Default is 0.</li>
<li><strong>drop_last (bool):</strong>  Specifies whether to drop last non-full batch.
Used only when batch_size &gt; 0.
Default is False.</li>
<li><strong>copy_data (bool):</strong>  Specifies whether to copy the tile before returning it.
If <code>copy_data == False</code>, returns a view.
Default is True.</li>
</ul>

<h6 id="yields">Yields</h6>

<blockquote>
  <p>(int, np.ndarray): Tuple with integer tile number and array tile data.</p>
</blockquote>
</div>


                            </div>
                            <div id="Tiler.get_tile" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Tiler.get_tile">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_tile</span><span class="signature">(
    self,
    data: Union[numpy.ndarray, Callable[..., numpy.ndarray]],
    tile_id: int,
    copy_data: bool = True
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                 <span class="n">tile_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">copy_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns an individual tile.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray or callable): Data from which `tile_id`-th tile will be taken. A callable can be</span>
<span class="sd">                supplied to load data into memory instead of slicing from an array. The callable should take integers</span>
<span class="sd">                as input, the smallest tile corner coordinates and tile size in each dimension, and output numpy array.</span>

<span class="sd">                e.g.</span>
<span class="sd">                *python-bioformats*</span>
<span class="sd">                ```python</span>
<span class="sd">                &gt;&gt;&gt; tileSize = 2000</span>
<span class="sd">                &gt;&gt;&gt; tiler = Tiler((sizeX, sizeY, sizeC), (tileSize, tileSize, sizeC))</span>
<span class="sd">                &gt;&gt;&gt; def reader_func(*args):</span>
<span class="sd">                &gt;&gt;&gt;     X, Y, W, H = args[0], args[1], args[3], args[4]</span>
<span class="sd">                &gt;&gt;&gt;     return reader.read(XYWH=[X, Y, W, H])</span>
<span class="sd">                &gt;&gt;&gt; tiler.get_tile(reader_func, 0)</span>
<span class="sd">                ```</span>
<span class="sd">                *open-slide*</span>
<span class="sd">                ```python</span>
<span class="sd">                &gt;&gt;&gt; reader_func = lambda *args: wsi.read_region([args[0], args[1]], 0, [args[3], args[4]])</span>
<span class="sd">                &gt;&gt;&gt; tiler.get_tile(reader_func, 0)</span>
<span class="sd">                ```</span>

<span class="sd">            tile_id (int): Specifies which tile to return. Must be smaller than the total number of tiles.</span>

<span class="sd">            copy_data (bool): Specifies whether returned tile is a copy.</span>
<span class="sd">                If `copy_data == False` returns a view.</span>
<span class="sd">                Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Content of tile number `tile_id`, padded if necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds, there is no tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1">.&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> tiles, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="c1"># get tile data</span>
        <span class="n">tile_corner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="p">[</span><span class="n">tile_id</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span>
        <span class="c1"># take the lesser of the tile shape and the distance to the edge</span>
        <span class="n">sampling</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">tile_corner</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">tile_corner</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">[</span><span class="n">d</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">sampling</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sampling</span><span class="p">]</span>
            <span class="n">tile_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">(</span><span class="o">*</span><span class="n">tile_corner</span><span class="p">,</span> <span class="o">*</span><span class="n">sampling</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tile_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sampling</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">copy_data</span><span class="p">:</span>
            <span class="n">tile_data</span> <span class="o">=</span> <span class="n">tile_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">shape_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">-</span> <span class="n">tile_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;irregular&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">shape_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
                <span class="n">tile_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">tile_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">shape_diff</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
                                   <span class="n">constant_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constant_value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;reflect&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
                <span class="n">tile_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">tile_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">shape_diff</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tile_data</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns an individual tile.</p>

<h6 id="args">Args</h6>

<ul>
<li><p><strong>data (np.ndarray or callable):</strong>  Data from which <code>tile_id</code>-th tile will be taken. A callable can be
supplied to load data into memory instead of slicing from an array. The callable should take integers
as input, the smallest tile corner coordinates and tile size in each dimension, and output numpy array.</p>

<p>e.g.
<em>python-bioformats</em></p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">tileSize</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tiler</span> <span class="o">=</span> <span class="n">Tiler</span><span class="p">((</span><span class="n">sizeX</span><span class="p">,</span> <span class="n">sizeY</span><span class="p">,</span> <span class="n">sizeC</span><span class="p">),</span> <span class="p">(</span><span class="n">tileSize</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">,</span> <span class="n">sizeC</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">reader_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">return</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">XYWH</span><span class="o">=</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tiler</span><span class="o">.</span><span class="n">get_tile</span><span class="p">(</span><span class="n">reader_func</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<p><em>open-slide</em></p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">reader_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">wsi</span><span class="o">.</span><span class="n">read_region</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tiler</span><span class="o">.</span><span class="n">get_tile</span><span class="p">(</span><span class="n">reader_func</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></li>
<li><strong>tile_id (int):</strong>  Specifies which tile to return. Must be smaller than the total number of tiles.</li>
<li><strong>copy_data (bool):</strong>  Specifies whether returned tile is a copy.
If <code>copy_data == False</code> returns a view.
Default is True.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>np.ndarray: Content of tile number <code>tile_id</code>, padded if necessary.</p>
</blockquote>
</div>


                            </div>
                            <div id="Tiler.get_tile_bbox_position" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Tiler.get_tile_bbox_position">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_tile_bbox_position</span><span class="signature">(
    self,
    tile_id: int,
    with_channel_dim: bool = False
) -&gt; Tuple[numpy.ndarray, numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_tile_bbox_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">with_channel_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns opposite corners coordinates of bounding hyperrectangle of the tile on padded data.</span>

<span class="sd">        Args:</span>
<span class="sd">            tile_id (int): Specifies which tile&#39;s bounding coordinates will be returned.</span>
<span class="sd">                Must be smaller than the total number of tiles.</span>

<span class="sd">            with_channel_dim (bool): Specifies whether to return shape with channel dimension or without.</span>
<span class="sd">                Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.ndarray): Smallest and largest corners of the bounding box.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds, there is no tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1">. &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> tiles, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="n">starting_corner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tile_mosaic_position</span><span class="p">(</span><span class="n">tile_id</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">finish_corner</span> <span class="o">=</span> <span class="n">starting_corner</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">with_channel_dim</span><span class="p">:</span>
            <span class="n">dim_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">))</span> <span class="o">+</span> \
                          <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile_step</span><span class="p">)))</span>
            <span class="n">starting_corner</span> <span class="o">=</span> <span class="n">starting_corner</span><span class="p">[</span><span class="n">dim_indices</span><span class="p">]</span>
            <span class="n">finish_corner</span> <span class="o">=</span> <span class="n">finish_corner</span><span class="p">[</span><span class="n">dim_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">starting_corner</span><span class="p">,</span> <span class="n">finish_corner</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns opposite corners coordinates of bounding hyperrectangle of the tile on padded data.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>tile_id (int):</strong>  Specifies which tile's bounding coordinates will be returned.
Must be smaller than the total number of tiles.</li>
<li><strong>with_channel_dim (bool):</strong>  Specifies whether to return shape with channel dimension or without.
Default is False.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>(np.ndarray, np.ndarray): Smallest and largest corners of the bounding box.</p>
</blockquote>
</div>


                            </div>
                            <div id="Tiler.get_tile_mosaic_position" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Tiler.get_tile_mosaic_position">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_tile_mosaic_position</span><span class="signature">(self, tile_id: int, with_channel_dim: bool = False) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_tile_mosaic_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">with_channel_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns tile position in the mosaic.</span>

<span class="sd">        Args:</span>
<span class="sd">          tile_id (int): Specifies which tile&#39;s mosaic position will be returned. \</span>
<span class="sd">            Must be smaller than the total number of tiles.</span>
<span class="sd">          with_channel_dim (bool): Specifies whether to return position with channel dimension or without.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Tile mosaic position (tile position relative to other tiles).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tile_id</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds, there is no tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1">. &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> tiles, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">with_channel_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="p">[</span><span class="n">tile_id</span><span class="p">][</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile_index</span><span class="p">[</span><span class="n">tile_id</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns tile position in the mosaic.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>tile_id (int):</strong>  Specifies which tile's mosaic position will be returned.             Must be smaller than the total number of tiles.</li>
<li><strong>with_channel_dim (bool):</strong>  Specifies whether to return position with channel dimension or without.
Default is False.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>np.ndarray: Tile mosaic position (tile position relative to other tiles).</p>
</blockquote>
</div>


                            </div>
                            <div id="Tiler.get_mosaic_shape" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Tiler.get_mosaic_shape">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_mosaic_shape</span><span class="signature">(self, with_channel_dim: bool = False) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_mosaic_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_channel_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns mosaic shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            with_channel_dim (bool):</span>
<span class="sd">                Specifies whether to return shape with channel dimension or without. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Shape of tiles mosaic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">with_channel_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexing_shape</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns mosaic shape.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>with_channel_dim (bool):</strong>  Specifies whether to return shape with channel dimension or without. Defaults to False.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>np.ndarray: Shape of tiles mosaic.</p>
</blockquote>
</div>


                            </div>
                </section>
                <section id="Merger">
                                <div class="attr class">
        <a class="headerlink" href="#Merger">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Merger</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Merger</span><span class="p">:</span>

    <span class="n">SUPPORTED_WINDOWS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;boxcar&#39;</span><span class="p">,</span> <span class="s1">&#39;triang&#39;</span><span class="p">,</span> <span class="s1">&#39;blackman&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="s1">&#39;bartlett&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;flattop&#39;</span><span class="p">,</span> <span class="s1">&#39;parzen&#39;</span><span class="p">,</span> <span class="s1">&#39;bohman&#39;</span><span class="p">,</span> <span class="s1">&#39;blackmanharris&#39;</span><span class="p">,</span> <span class="s1">&#39;nuttall&#39;</span><span class="p">,</span> <span class="s1">&#39;barthann&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;overlap-tile&#39;</span><span class="p">]</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Supported windows:</span>
<span class="sd">    - &#39;boxcar&#39; (default)  </span>
<span class="sd">        Boxcar window: the weight of each is tile element is 1.  </span>
<span class="sd">        Also known as rectangular window or Dirichlet window (and equivalent to no window at all).</span>
<span class="sd">    - &#39;triang&#39;  </span>
<span class="sd">        Triangular window.</span>
<span class="sd">    - &#39;blackman&#39;  </span>
<span class="sd">        Blackman window.</span>
<span class="sd">    - &#39;hamming&#39;  </span>
<span class="sd">        Hamming window.</span>
<span class="sd">    - &#39;hann&#39;  </span>
<span class="sd">        Hann window.</span>
<span class="sd">    - &#39;bartlett&#39;  </span>
<span class="sd">        Bartlett window.</span>
<span class="sd">    - &#39;flattop&#39;  </span>
<span class="sd">        Flat top window.</span>
<span class="sd">    - &#39;parzen&#39;  </span>
<span class="sd">        Parzen window.</span>
<span class="sd">    - &#39;bohman&#39;  </span>
<span class="sd">        Bohman window.</span>
<span class="sd">    - &#39;blackmanharris&#39;  </span>
<span class="sd">        Minimum 4-term Blackman-Harris window.</span>
<span class="sd">    - &#39;nuttall&#39;  </span>
<span class="sd">        Minimum 4-term Blackman-Harris window according to Nuttall.</span>
<span class="sd">    - &#39;barthann&#39;  </span>
<span class="sd">        Bartlett-Hann window.    </span>
<span class="sd">    - &#39;overlap-tile&#39;  </span>
<span class="sd">        Creates a boxcar window for the non-overlapping, middle part of tile, and zeros everywhere else.</span>
<span class="sd">        (Ronneberger et al. 2015, U-Net paper)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">tiler</span><span class="p">:</span> <span class="n">Tiler</span><span class="p">,</span>
                 <span class="n">window</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">logits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merger precomputes everything for merging together tiles created by given Tiler.</span>

<span class="sd">        TODO:</span>
<span class="sd">            - generate window depending on tile border type</span>

<span class="sd">        Args:</span>
<span class="sd">            tiler (Tiler): Tiler with which the tiles were originally created.</span>

<span class="sd">            window (None, str or np.ndarray): Specifies which window function to use for tile merging.</span>
<span class="sd">                Must be one of `Merger.SUPPORTED_WINDOWS` or a numpy array with the same size as the tile.</span>
<span class="sd">                Default is None which creates a boxcar window (constant 1s).</span>

<span class="sd">            logits (int): Specify whether to add logits dimensions in front of the data array. Default is `0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span> <span class="o">=</span> <span class="n">tiler</span>

        <span class="c1"># Logits support</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">logits</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Logits must be an integer 0 or a positive number (</span><span class="si">{</span><span class="n">logits</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logits</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>

        <span class="c1"># Generate data and normalization arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_visits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_sum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># for the future borders generation</span>
        <span class="c1"># 1d = 3 types of tiles: 2 corners and middle</span>
        <span class="c1"># 2d = 9 types of tiles: 4 corners, 4 tiles with 1 edge and middle</span>
        <span class="c1"># 3d = 25 types of tiles: 8 corners, 12 tiles with 2 edges, 6 tiles with one edge and middle</span>
        <span class="c1"># corners: 2^ndim</span>
        <span class="c1"># tiles: 2*ndim*nedges</span>

        <span class="c1"># Generate window function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_window</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generate n-dimensional window according to the given shape.</span>
<span class="sd">        Adapted from: https://stackoverflow.com/a/53588640/1668421</span>
<span class="sd">        We use scipy to generate windows (scipy.signal.get_window()).</span>

<span class="sd">        Args:</span>
<span class="sd">            window (str): Specifies window function. Must be one of `Merger.SUPPORTED_WINDOWS`.</span>
<span class="sd">            shape (tuple or list): Shape of the requested window.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: n-dimensional window of the given shape and function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">_tile_overlap</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">channel_dimension</span><span class="p">:</span>
                <span class="c1"># channel dimension should have weight of 1 everywhere</span>
                <span class="n">win</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="s1">&#39;boxcar&#39;</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;overlap-tile&#39;</span><span class="p">:</span>
                    <span class="n">axis_overlap</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
                    <span class="n">win</span><span class="p">[</span><span class="n">axis_overlap</span><span class="p">:</span><span class="o">-</span><span class="n">axis_overlap</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">win</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">win</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

            <span class="n">w</span> <span class="o">*=</span> <span class="n">win</span>

        <span class="k">return</span> <span class="n">w</span>

    <span class="k">def</span> <span class="nf">set_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets window function depending on the given window function.</span>

<span class="sd">        Args:</span>
<span class="sd">            window (None, str or np.ndarray): Specifies which window function to use for tile merging.</span>
<span class="sd">                Must be one of `Merger.SUPPORTED_WINDOWS` or a numpy array with the same size as the tile.</span>
<span class="sd">                If passed None sets a boxcar window (constant 1s).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Warn user that changing window type after some elements were already visited is a bad idea.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_visits</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;You are setting window type after some elements were already added.&#39;</span><span class="p">)</span>

        <span class="c1"># Default window is boxcar</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="s1">&#39;boxcar&#39;</span>

        <span class="c1"># Generate or set a window function</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">window</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_WINDOWS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unsupported window, please check docs&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Window function must have the same shape as tile shape.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unsupported type for window function (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="si">}</span><span class="s1">), expected str or np.ndarray.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset data and normalization buffers.</span>

<span class="sd">        Should be done after finishing merging full tile set and before starting processing the next tile set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">padded_data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">_new_shape</span>

        <span class="c1"># Image holds sum of all processed tiles multiplied by the window</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logits</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">logits</span><span class="p">,</span> <span class="o">*</span><span class="n">padded_data_shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padded_data_shape</span><span class="p">)</span>

        <span class="c1"># Normalization array holds the number of times each element was visited</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_visits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padded_data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

        <span class="c1"># Total data window (weight) coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padded_data_shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds `tile_id`-th tile into Merger.</span>

<span class="sd">        Args:</span>
<span class="sd">            tile_id (int): Specifies which tile it is.</span>
<span class="sd">            data (np.ndarray): Specifies tile data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tile_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tile_id</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds, there is no tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1">. &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="p">)</span><span class="si">}</span><span class="s1"> tiles, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="n">data_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">expected_tile_shape</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">logits</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logits</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;irregular&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">expected_tile_shape</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Passed data shape (</span><span class="si">{</span><span class="n">data_shape</span><span class="si">}</span><span class="s1">) &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;does not fit expected tile shape (</span><span class="si">{</span><span class="n">expected_tile_shape</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">expected_tile_shape</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Passed data shape (</span><span class="si">{</span><span class="n">data_shape</span><span class="si">}</span><span class="s1">) &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;must be less or equal than tile shape (</span><span class="si">{</span><span class="n">expected_tile_shape</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>

        <span class="c1"># Select coordinates for data</span>
        <span class="n">shape_diff</span> <span class="o">=</span> <span class="n">expected_tile_shape</span> <span class="o">-</span> <span class="n">data_shape</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">get_tile_bbox_position</span><span class="p">(</span><span class="n">tile_id</span><span class="p">,</span> <span class="n">with_channel_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">shape_diff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))]</span>
        <span class="n">win_sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">diff</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">shape_diff</span><span class="p">]</span>

        <span class="c1"># TODO check for self.data and data dtypes mismatch?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">win_sl</span><span class="p">[</span><span class="mi">1</span><span class="p">:])])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights_sum</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">win_sl</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">win_sl</span><span class="p">)])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights_sum</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">win_sl</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_visits</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">add_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds `batch_id`-th batch of `batch_size` tiles into Merger.</span>

<span class="sd">        Args:</span>
<span class="sd">            batch_id (int): Specifies batch number, must be &gt;= 0.</span>
<span class="sd">            batch_size (int): Specifies batch size, must be &gt;= 0.</span>
<span class="sd">            data (np.ndarray): Tile data array, must have shape `[batch, *tile_shape]</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate total number of batches</span>
        <span class="n">div</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">)</span>
        <span class="n">n_batches</span> <span class="o">=</span> <span class="p">(</span><span class="n">div</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">mod</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">div</span>

        <span class="k">if</span> <span class="n">batch_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">batch_id</span> <span class="o">&gt;=</span> <span class="n">n_batches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds. There are </span><span class="si">{</span><span class="n">n_batches</span><span class="si">}</span><span class="s1"> batches of </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s1">, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="c1"># add each tile in a batch with computed tile_id</span>
        <span class="k">for</span> <span class="n">data_i</span><span class="p">,</span> <span class="n">tile_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">batch_id</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span>
                                        <span class="nb">min</span><span class="p">((</span><span class="n">batch_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="p">)))):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tile_i</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">data_i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unpad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">argmax</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns final merged data array obtained from added tiles.</span>

<span class="sd">        Args:</span>
<span class="sd">            unpad (bool): If unpad is True, removes padded array elements. Default is True.</span>
<span class="sd">            argmax (bool): If argmax is True, the first dimension will be argmaxed. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Final merged data array obtained from added tiles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="n">unpad</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">data_shape</span><span class="p">))]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logits</span><span class="p">:</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="n">sl</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">argmax</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>
</pre></div>

        </details>

    

                            <div id="Merger.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Merger.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Merger</span><span class="signature">(
    tiler: <a href="#tiler.Tiler">tiler.tiler.Tiler</a>,
    window: Union[NoneType, str, numpy.ndarray] = None,
    logits: int = 0
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">tiler</span><span class="p">:</span> <span class="n">Tiler</span><span class="p">,</span>
                 <span class="n">window</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">logits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merger precomputes everything for merging together tiles created by given Tiler.</span>

<span class="sd">        TODO:</span>
<span class="sd">            - generate window depending on tile border type</span>

<span class="sd">        Args:</span>
<span class="sd">            tiler (Tiler): Tiler with which the tiles were originally created.</span>

<span class="sd">            window (None, str or np.ndarray): Specifies which window function to use for tile merging.</span>
<span class="sd">                Must be one of `Merger.SUPPORTED_WINDOWS` or a numpy array with the same size as the tile.</span>
<span class="sd">                Default is None which creates a boxcar window (constant 1s).</span>

<span class="sd">            logits (int): Specify whether to add logits dimensions in front of the data array. Default is `0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span> <span class="o">=</span> <span class="n">tiler</span>

        <span class="c1"># Logits support</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">logits</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Logits must be an integer 0 or a positive number (</span><span class="si">{</span><span class="n">logits</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logits</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>

        <span class="c1"># Generate data and normalization arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_visits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_sum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># for the future borders generation</span>
        <span class="c1"># 1d = 3 types of tiles: 2 corners and middle</span>
        <span class="c1"># 2d = 9 types of tiles: 4 corners, 4 tiles with 1 edge and middle</span>
        <span class="c1"># 3d = 25 types of tiles: 8 corners, 12 tiles with 2 edges, 6 tiles with one edge and middle</span>
        <span class="c1"># corners: 2^ndim</span>
        <span class="c1"># tiles: 2*ndim*nedges</span>

        <span class="c1"># Generate window function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_window</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Merger precomputes everything for merging together tiles created by given Tiler.</p>

<h6 id="todo">TODO</h6>

<blockquote>
  <ul>
  <li>generate window depending on tile border type</li>
  </ul>
</blockquote>

<h6 id="args">Args</h6>

<ul>
<li><strong>tiler (Tiler):</strong>  Tiler with which the tiles were originally created.</li>
<li><strong>window (None, str or np.ndarray):</strong>  Specifies which window function to use for tile merging.
Must be one of <code><a href="#Merger.SUPPORTED_WINDOWS">Merger.SUPPORTED_WINDOWS</a></code> or a numpy array with the same size as the tile.
Default is None which creates a boxcar window (constant 1s).</li>
<li><strong>logits (int):</strong>  Specify whether to add logits dimensions in front of the data array. Default is <code>0</code>.</li>
</ul>
</div>


                            </div>
                            <div id="Merger.SUPPORTED_WINDOWS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Merger.SUPPORTED_WINDOWS">#&nbsp;&nbsp</a>

        <span class="name">SUPPORTED_WINDOWS</span><span class="default_value"> = [&#39;boxcar&#39;, &#39;triang&#39;, &#39;blackman&#39;, &#39;hamming&#39;, &#39;hann&#39;, &#39;bartlett&#39;, &#39;flattop&#39;, &#39;parzen&#39;, &#39;bohman&#39;, &#39;blackmanharris&#39;, &#39;nuttall&#39;, &#39;barthann&#39;, &#39;overlap-tile&#39;]</span>
    </div>

            <div class="docstring"><p>Supported windows:</p>

<ul>
<li>'boxcar' (default) <br />
Boxcar window: the weight of each is tile element is 1. <br />
Also known as rectangular window or Dirichlet window (and equivalent to no window at all).</li>
<li>'triang' <br />
Triangular window.</li>
<li>'blackman' <br />
Blackman window.</li>
<li>'hamming' <br />
Hamming window.</li>
<li>'hann' <br />
Hann window.</li>
<li>'bartlett' <br />
Bartlett window.</li>
<li>'flattop' <br />
Flat top window.</li>
<li>'parzen' <br />
Parzen window.</li>
<li>'bohman' <br />
Bohman window.</li>
<li>'blackmanharris' <br />
Minimum 4-term Blackman-Harris window.</li>
<li>'nuttall' <br />
Minimum 4-term Blackman-Harris window according to Nuttall.</li>
<li>'barthann' <br />
Bartlett-Hann window.    </li>
<li>'overlap-tile' <br />
Creates a boxcar window for the non-overlapping, middle part of tile, and zeros everywhere else.
(Ronneberger et al. 2015, U-Net paper)</li>
</ul>
</div>


                            </div>
                            <div id="Merger.set_window" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Merger.set_window">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_window</span><span class="signature">(self, window: Union[NoneType, str, numpy.ndarray] = None) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets window function depending on the given window function.</span>

<span class="sd">        Args:</span>
<span class="sd">            window (None, str or np.ndarray): Specifies which window function to use for tile merging.</span>
<span class="sd">                Must be one of `Merger.SUPPORTED_WINDOWS` or a numpy array with the same size as the tile.</span>
<span class="sd">                If passed None sets a boxcar window (constant 1s).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Warn user that changing window type after some elements were already visited is a bad idea.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_visits</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;You are setting window type after some elements were already added.&#39;</span><span class="p">)</span>

        <span class="c1"># Default window is boxcar</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="s1">&#39;boxcar&#39;</span>

        <span class="c1"># Generate or set a window function</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">window</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_WINDOWS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unsupported window, please check docs&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Window function must have the same shape as tile shape.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unsupported type for window function (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="si">}</span><span class="s1">), expected str or np.ndarray.&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets window function depending on the given window function.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>window (None, str or np.ndarray):</strong>  Specifies which window function to use for tile merging.
Must be one of <code><a href="#Merger.SUPPORTED_WINDOWS">Merger.SUPPORTED_WINDOWS</a></code> or a numpy array with the same size as the tile.
If passed None sets a boxcar window (constant 1s).</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>None</p>
</blockquote>
</div>


                            </div>
                            <div id="Merger.reset" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Merger.reset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">reset</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset data and normalization buffers.</span>

<span class="sd">        Should be done after finishing merging full tile set and before starting processing the next tile set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">padded_data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">_new_shape</span>

        <span class="c1"># Image holds sum of all processed tiles multiplied by the window</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logits</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">logits</span><span class="p">,</span> <span class="o">*</span><span class="n">padded_data_shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padded_data_shape</span><span class="p">)</span>

        <span class="c1"># Normalization array holds the number of times each element was visited</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_visits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padded_data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

        <span class="c1"># Total data window (weight) coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padded_data_shape</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Reset data and normalization buffers.</p>

<p>Should be done after finishing merging full tile set and before starting processing the next tile set.</p>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>None</p>
</blockquote>
</div>


                            </div>
                            <div id="Merger.add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Merger.add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add</span><span class="signature">(self, tile_id: int, data: numpy.ndarray) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds `tile_id`-th tile into Merger.</span>

<span class="sd">        Args:</span>
<span class="sd">            tile_id (int): Specifies which tile it is.</span>
<span class="sd">            data (np.ndarray): Specifies tile data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tile_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tile_id</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds, there is no tile </span><span class="si">{</span><span class="n">tile_id</span><span class="si">}</span><span class="s1">. &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="p">)</span><span class="si">}</span><span class="s1"> tiles, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="n">data_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">expected_tile_shape</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">logits</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logits</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;irregular&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">expected_tile_shape</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Passed data shape (</span><span class="si">{</span><span class="n">data_shape</span><span class="si">}</span><span class="s1">) &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;does not fit expected tile shape (</span><span class="si">{</span><span class="n">expected_tile_shape</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">expected_tile_shape</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Passed data shape (</span><span class="si">{</span><span class="n">data_shape</span><span class="si">}</span><span class="s1">) &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;must be less or equal than tile shape (</span><span class="si">{</span><span class="n">expected_tile_shape</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>

        <span class="c1"># Select coordinates for data</span>
        <span class="n">shape_diff</span> <span class="o">=</span> <span class="n">expected_tile_shape</span> <span class="o">-</span> <span class="n">data_shape</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">get_tile_bbox_position</span><span class="p">(</span><span class="n">tile_id</span><span class="p">,</span> <span class="n">with_channel_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">shape_diff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))]</span>
        <span class="n">win_sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">diff</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">shape_diff</span><span class="p">]</span>

        <span class="c1"># TODO check for self.data and data dtypes mismatch?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">win_sl</span><span class="p">[</span><span class="mi">1</span><span class="p">:])])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights_sum</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">win_sl</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">win_sl</span><span class="p">)])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights_sum</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">win_sl</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_visits</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>tile_id</code>-th tile into Merger.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>tile_id (int):</strong>  Specifies which tile it is.</li>
<li><strong>data (np.ndarray):</strong>  Specifies tile data.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>None</p>
</blockquote>
</div>


                            </div>
                            <div id="Merger.add_batch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Merger.add_batch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add_batch</span><span class="signature">(self, batch_id: int, batch_size: int, data: numpy.ndarray) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">add_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds `batch_id`-th batch of `batch_size` tiles into Merger.</span>

<span class="sd">        Args:</span>
<span class="sd">            batch_id (int): Specifies batch number, must be &gt;= 0.</span>
<span class="sd">            batch_size (int): Specifies batch size, must be &gt;= 0.</span>
<span class="sd">            data (np.ndarray): Tile data array, must have shape `[batch, *tile_shape]</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate total number of batches</span>
        <span class="n">div</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">)</span>
        <span class="n">n_batches</span> <span class="o">=</span> <span class="p">(</span><span class="n">div</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">mod</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">div</span>

        <span class="k">if</span> <span class="n">batch_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">batch_id</span> <span class="o">&gt;=</span> <span class="n">n_batches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Out of bounds. There are </span><span class="si">{</span><span class="n">n_batches</span><span class="si">}</span><span class="s1"> batches of </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s1">, starting from index 0.&#39;</span><span class="p">)</span>

        <span class="c1"># add each tile in a batch with computed tile_id</span>
        <span class="k">for</span> <span class="n">data_i</span><span class="p">,</span> <span class="n">tile_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">batch_id</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span>
                                        <span class="nb">min</span><span class="p">((</span><span class="n">batch_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="p">)))):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tile_i</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">data_i</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>batch_id</code>-th batch of <code>batch_size</code> tiles into Merger.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>batch_id (int):</strong>  Specifies batch number, must be &gt;= 0.</li>
<li><strong>batch_size (int):</strong>  Specifies batch size, must be &gt;= 0.</li>
<li><strong>data (np.ndarray):</strong>  Tile data array, must have shape `[batch, *tile_shape]</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>None</p>
</blockquote>
</div>


                            </div>
                            <div id="Merger.merge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Merger.merge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">merge</span><span class="signature">(self, unpad: bool = True, argmax: bool = False) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unpad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">argmax</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns final merged data array obtained from added tiles.</span>

<span class="sd">        Args:</span>
<span class="sd">            unpad (bool): If unpad is True, removes padded array elements. Default is True.</span>
<span class="sd">            argmax (bool): If argmax is True, the first dimension will be argmaxed. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Final merged data array obtained from added tiles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="n">unpad</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiler</span><span class="o">.</span><span class="n">data_shape</span><span class="p">))]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logits</span><span class="p">:</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="n">sl</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">argmax</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns final merged data array obtained from added tiles.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>unpad (bool):</strong>  If unpad is True, removes padded array elements. Default is True.</li>
<li><strong>argmax (bool):</strong>  If argmax is True, the first dimension will be argmaxed. Default is False.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>np.ndarray: Final merged data array obtained from added tiles.</p>
</blockquote>
</div>


                            </div>
                </section>
    </main>
</body>
</html>